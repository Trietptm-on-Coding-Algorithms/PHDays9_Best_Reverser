# PHDays9_Best_Reverser

## sub_5EC ##

Значимый кусок кода:

```asm
move.l 0x2c(a2), d0
move.l       d0, d1
addq.l        1, d1
move.l       d1, 0x2c(a2)
movea.l      d0, a0
move.b     (a0), d0
```

где 0x2c(a2) всегда 0x00FF1D74

Этот кусок можно переписать так на псевдокоде:

```c
d0 = a2 + 0x2C
*(a2+0x2C) = *(a2+0x2C) + 1
result = *(d0) & 0xFF
```

То есть 4 байта из 0x00FF1D74 являются адресом, т.к. по ним извлекается значение из памяти.

Как переписать функцию sub_5EC на питоне?

1. Либо сделать дамп памяти и обращаться к нему
2. Либо просто записать все выдаваемые значения

Второй способ выглядит здорово, но что, если при разных данных авторизации выдаваемые значения разные?
Проверим это.

Поможет в этом скрипт

```c
#include <idc.idc>

static main()
{
    auto pc_val=0, d0_val;
    while(pc_val != 0x00001F16){
        
        pc_val = GetRegValue("pc");
        
        if (pc_val == 0x00001F9C)
            StepInto();
        else
            StepOver();
            
        GetDebuggerEvent(WFNE_SUSP, -1);
    
        if (pc_val == 0x00000674){
            d0_val = GetRegValue("d0") & 0xFF;
            print(d0_val);
        }
    }
}
```

Запустив скрипт несколько раз при разных ключах, мы видим, что функция sub_5EC всегда возвращает очередное значение из массива:

```python
def sub_5EC():
  dump = [0x92, 0x8A, 0xDC, 0xDC, 0x94, 0x3B, 0xE4, 0xE4,
          0xFC, 0xB3, 0xDC, 0xEE, 0xF4, 0xB4, 0xDC, 0xDE,
          0xFE, 0x68, 0x4A, 0xBD, 0x91, 0xD5, 0x0A, 0x27,
          0xED, 0xFF, 0xC2, 0xA5, 0xD6, 0xBF, 0xDE, 0xFA,
          0xA6, 0x72, 0xBF, 0x1A, 0xF6, 0xFA, 0xE4, 0xE7,
          0xFA, 0xF7, 0xF6, 0xD6, 0x91, 0xB4, 0xB4, 0xB5,
          0xB4, 0xF4, 0xA4, 0xF4, 0xF4, 0xB7, 0xF6, 0x09,
          0x20, 0xB7, 0x86, 0xF6, 0xE6, 0xF4, 0xE4, 0xC6,
          0xFE, 0xF6, 0x9D, 0x11, 0xD4, 0xFF, 0xB5, 0x68,
          0x4A, 0xB8, 0xD4, 0xF7, 0xAE, 0xFF, 0x1C, 0xB7,
          0x4C, 0xBF, 0xAD, 0x72, 0x4B, 0xBF, 0xAA, 0x3D,
          0xB5, 0x7D, 0xB5, 0x3D, 0xB9, 0x7D, 0xD9, 0x7D,
          0xB1, 0x13, 0xE1, 0xE1, 0x02, 0x15, 0xB3, 0xA3,
          0xB3, 0x88, 0x9E, 0x2C, 0xB0, 0x8F]
          
  l = len(dump)
  offset = 0
  
  while offset < l:
    yield dump[offset]
    offset += 1
  
```

Итак функция sub_5EC готова

## sub_E3E ##
